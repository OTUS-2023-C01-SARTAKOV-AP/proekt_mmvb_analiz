// предторовая работа (до 09-59-00) по наполнению всех структур в оперативной памяти историческими котировками

#include <stdio.h>
#include <stdlib.h> 
#include <string.h>
#include <wctype.h> 
#include <wchar.h> 
#include <time.h> 
#include <libpq-fe.h>
#include <ctype.h>
#include <iso646.h>
#include <stdbool.h>
#include <uchar.h> 
#include <locale.h>
#include <math.h>
#include <threads.h> 
#include <unistd.h>
#include <errno.h> 

#include "глобальные_переменные.h" 
#include "extern_активация.h"
#include "нагрузка_пк.h" 
#include "входные_данные.h" 
#include "ошибки_обработка.h" 
#include "системные_функции.h"
#include "файлы_действия.h"
#include "предстарт_наполнение.h"
#include "запросы_к_бд.h" 





#if 1==1
// наполнение первичными ценами          mm-mm-mm-mm-mm-mm      ****** по минуткам
// из БД в структурах в оперативной памяти сразу все акции по одному таймфрэйму
// у нас есть глобальный список акций для работы и именно в той же последовательности мы заплняем ВСЕ СТРУКТУРЫ данными!
    // (разные потоки=разные таймфрэймы, но один биржевой инструмент! 
void *fбд_предстарт_потоки_mm(void *параметры)
{
    PGresult *результат_запроса;  // локальный    
    int max_poit = глоб_об_ключи_запуска.точек_вданных;   
    PGconn* связь_сервер_quik; 
    
    ПОТОКИ_объект_Timeframe *структура_разбор =  (ПОТОКИ_объект_Timeframe *) параметры; 
    
    int номер_таймфрэйма = структура_разбор->номер_таймфрэйма;    
    struct таймфрэйм_шаблон *адрес_структуры = глоб_об_таймфрэймы_описание.адрес_в_памяти[структура_разбор->номер_таймфрэйма];    
    char таймфрэйм_имя[8];
    strcpy(таймфрэйм_имя, структура_разбор->ars_имя_таймфрэйм);
    int шаг_вминутах = структура_разбор->шаг_вминутах;
    
    if (1 == глоб_об_ключи_запуска.независимых_потоков)
    {
        связь_сервер_quik  = (PGconn*) (структура_разбор->связь_сервер_quik);
    }
    else
    {
        связь_сервер_quik = fбд_соединение_бд();
    }
    
    
    // тесты результат_запроса = PQexec(связь_сервер_quik, "select count(*) from db_log.нагрузка_системы; ");    
    // тесты printf("БД) записей в БД = %s \n", PQgetvalue(результат_запроса, 0, 0));
    printf("БД)  [%i] \tимя_таймфрэйм = %s, \tномер_таймфрэйма = %i  \tшаг_вминутах = %i\n", номер_таймфрэйма, таймфрэйм_имя, номер_таймфрэйма, шаг_вминутах); // параметры = %p" , (void*)параметры); 
    
    for (int i=0; i<глоб_список_secid_штук; i++)
    {        
        int row_number = 0;
        int текущее_время=0;
        int предшествующее_время=0;
        double ц_откр=0;
        double ц_макс=0;
        double ц_мин=0;
        double ц_закр=0;
        long int акций_шт=0;
        int создали_точек=1; // именно с 1   ВНИМАНИЕ!!!
        
        //char стр0[8]=""; 
        char стр1[8]=""; 
        char стр2[8]="";       
        const char *paramValues2[3];

        //sprintf(стр0, "%s",  глоб_список_secid[i]);     
        paramValues2[0] = глоб_список_secid[i]; 
        
        sprintf(стр1, "%i", max_poit); 
        paramValues2[1] = стр1; // (char *) &стр1; НОВШЕСТВО и ОНО РАБОТАЕТ!!!! ДЛЯ БИНАРНЫХ ФАЙЛОВ
        

        sprintf(стр2, "%i", шаг_вминутах); 
        paramValues2[2] = стр2; 

        // получение исторических данных по минуткам дополнительно скачиваем ctid
        char* п_запрос_1=" select t1.ctid, t1.secid, t1.open, t1.high, t1.low, t1.close, "
        " (t1.акций_шт/coalesce(t2.lotsize, 1)) as акций_шт, "
        " div((EXTRACT(epoch FROM t1.дата_начало)), 60) as время_эпоха " 
        " from акции_рф.t_m_1 as t1 "
        " left join справочники.t_securities_расширенный as t2 "
        "     on t1.secid = t2.secid"
        " where  t1.secid=$1 " 
        " order by t1.дата_начало desc limit $2::int * $3::int "; 

        
        //printf("%s\n",п_запрос_1);
        результат_запроса = PQexecParams(связь_сервер_quik, п_запрос_1, 3, NULL, 
            paramValues2, NULL, NULL, 0);   
        
        if (PQresultStatus(результат_запроса) == PGRES_TUPLES_OK) // успешное завершение команды, которая возвращает данные (PGRES_COMMAND_OK=без возврата данных)
        {         
            // возвращает число строк (кортежей) в полученной выборке (срок с результатами)
            row_number = PQntuples(результат_запроса);
            
            strcpy(адрес_структуры[i].ars_secid,  глоб_список_secid[i]);   //имя эмитента, торговый инструмент SBERP
                
            
            for (int кортеж=0; кортеж<row_number; кортеж++)
            {
                
                текущее_время=(atoi(PQgetvalue(результат_запроса, кортеж, 7))) - ((atoi(PQgetvalue(результат_запроса, кортеж, 7))) % шаг_вминутах ); //кратно шагу времени
                
                if (0==кортеж) // для самой новой точки заполняем ключевые точки по времени и обнуляем ключи = "расчеты индикаторов"
                {
                    // это ключевые точки времени, относительно которых делаются вычисления
                    
                    предшествующее_время=текущее_время - шаг_вминутах;  
                    
                    адрес_структуры[i].время_предыдущее_вминутах = предшествующее_время; // в струткуре всего одно точка и она записывается как последняя (конец торгового дня)
                    адрес_структуры[i].время_последнее_вминутах = текущее_время ; // в коде ниже - мы заполняем массив временнем для вывода потом по ним графиков
                    адрес_структуры[i].время_будущее_вминутах = текущее_время + шаг_вминутах; // нужно для следующего дня (его начала)
                    
                    адрес_структуры[i].нужно_обновить_индикаторы = false; 
                    адрес_структуры[i].нужно_пересчитать_индикаторы = false; 
        
                    ц_откр=atof(PQgetvalue(результат_запроса, кортеж, 2));
                    ц_макс=atof(PQgetvalue(результат_запроса, кортеж, 3));
                    ц_мин=atof(PQgetvalue(результат_запроса, кортеж, 4));
                    ц_закр=atof(PQgetvalue(результат_запроса, кортеж, 5));
                    акций_шт=atol(PQgetvalue(результат_запроса, кортеж, 6));
                }                    
                
                    // только для таймфрэйма = 1 минута заполняем ctid_последний и только для самой новой точки 
                if (0==кортеж and 1 == шаг_вминутах)
                {
                    strcpy(адрес_структуры[i].ctid_последний, PQgetvalue(результат_запроса, кортеж, 0));  
                        // последние коодинаты минуток (самое свежее время по ценам), относительно них крутятся все обновления и цен и индикаторов
                        // для некоторых инструментов завтра - этот элемен может не меняться минут 30-60!!!
                }
                
                // у нас идет обратная сортировка (на убывание) правило ниже это главный элемент этого кода (обратный отсчет меток)!!! не трогать. проверено!
                if (предшествующее_время >= текущее_время  ) 
                {                       
                    предшествующее_время=текущее_время - шаг_вминутах;                     
                    
                    // обнуляем все интервальные переменные. 
                    ц_откр=atof(PQgetvalue(результат_запроса, кортеж, 2));
                    ц_макс=atof(PQgetvalue(результат_запроса, кортеж, 3));
                    ц_мин=atof(PQgetvalue(результат_запроса, кортеж, 4));
                    ц_закр=atof(PQgetvalue(результат_запроса, кортеж, 5));
                    акций_шт=atol(PQgetvalue(результат_запроса, кортеж, 6));

                    создали_точек =создали_точек +1;
                    if (создали_точек > max_poit) 
                    {
                        кортеж=row_number+10;
                        break;
                    }
                } // select ctid, secid, open, high, low, close, акций_шт, "
                else
                {
                        // считаем промежуточные значения. идем в обратную сторону поэтому наоборот закр и открытие
                    ц_откр=atof(PQgetvalue(результат_запроса, кортеж, 2));
                    ц_макс=(ц_макс > atof(PQgetvalue(результат_запроса, кортеж, 3))) ? ц_макс : atof(PQgetvalue(результат_запроса, кортеж, 3)) ;
                    ц_мин=(ц_мин   < atof(PQgetvalue(результат_запроса, кортеж, 4))) ? ц_мин  : atof(PQgetvalue(результат_запроса, кортеж, 4)) ;
                    //ц_закр=atof(PQgetvalue(результат_запроса, кортеж, 5));
                    акций_шт=акций_шт + atol(PQgetvalue(результат_запроса, кортеж, 6));
                }
                    // цены, но данные из БД получены в обратном порядке, т.к заранее неизвестно сколько реальных точек с данными придёт
                    // поэтому данные сохраняем на каждом цикле
                адрес_структуры[i].ard_ц_откр[max_poit-создали_точек] = ц_откр;  
                адрес_структуры[i].ard_ц_макс[max_poit-создали_точек] = ц_макс;
                адрес_структуры[i].ard_ц_мин[max_poit-создали_точек] =  ц_мин;
                адрес_структуры[i].ard_ц_закр[max_poit-создали_точек] = ц_закр;
                адрес_структуры[i].ari_акций_шт[max_poit-создали_точек] = акций_шт;
                адрес_структуры[i].ari_время_эпохи_вминутах[max_poit-создали_точек] = текущее_время; 
                адрес_структуры[i].доступно_срезов_цен = создали_точек;           // кол-во срезов времени (при норме 230 может оказаться всего 156)
            }        
        }
        else if (PQresultStatus(результат_запроса) != PGRES_TUPLES_OK)
        {
            PQsetErrorContextVisibility(связь_сервер_quik,  PQSHOW_CONTEXT_ALWAYS);
            PQsetErrorVerbosity(связь_сервер_quik,  PQERRORS_VERBOSE);
            char er_msg[5000]="# ";
            strcat(er_msg, PQerrorMessage(связь_сервер_quik));  // ОДИНАКОВО!!! = strcat(er_msg, PQresultErrorMessage(результат_запроса)); 
            strcat(er_msg, " ");
            
            fо_текст_ошибки(er_msg, -40);    
            printf("\t ОШИБКА:  %s\n", er_msg); 
        }
        PQclear(результат_запроса); 
        
        fс_автопауза_вциклах();
    }
    
    if (5==шаг_вминутах)
    {
        //fф_сообщ_тесты_срезов_цен("m5", "GAZP", 20);
    }
    
    return ((void*) 0); // или число = ((void*) 15);
}
#endif




#if 1==1
// наполнение первичными ценами          mm-mm-mm-mm-mm-mm      ****** по минуткам
// из БД в структурах в оперативной памяти сразу все акции по одному таймфрэйму
// у нас есть глобальный список акций для работы и именно в той же последовательности мы заплняем ВСЕ СТРУКТУРЫ данными!
    // (разные потоки=разные таймфрэймы, но один биржевой инструмент! 
int fбд_утро_цены_вструктуры_mm(char* таймфрэйм_имя, struct таймфрэйм_шаблон *адрес_структуры, int шаг_вминутах, PGconn* связь_сервер_quik)
{
    PGresult *результат_запроса;  // локальный    
    int max_poit = глоб_об_ключи_запуска.точек_вданных;
    
    
    for (int i=0; i<глоб_список_secid_штук; i++)
    {        
        int row_number = 0;
        int текущее_время=0;
        int предшествующее_время=0;
        double ц_откр=0;
        double ц_макс=0;
        double ц_мин=0;
        double ц_закр=0;
        long int акций_шт=0;
        int создали_точек=1; // именно с 1   ВНИМАНИЕ!!!
        
        //char стр0[8]=""; 
        char стр1[8]=""; 
        char стр2[8]="";       
        const char *paramValues2[3];

        //sprintf(стр0, "%s",  глоб_список_secid[i]);     
        paramValues2[0] = глоб_список_secid[i]; 
        
        sprintf(стр1, "%i", max_poit); 
        paramValues2[1] = стр1; // (char *) &стр1; НОВШЕСТВО и ОНО РАБОТАЕТ!!!! ДЛЯ БИНАРНЫХ ФАЙЛОВ
        

        sprintf(стр2, "%i", шаг_вминутах); 
        paramValues2[2] = стр2; 

        // получение исторических данных по минуткам дополнительно скачиваем ctid
        char* п_запрос_1=" select t1.ctid, t1.secid, t1.open, t1.high, t1.low, t1.close, "
        " (t1.акций_шт/coalesce(t2.lotsize, 1)) as акций_шт, "
        " div((EXTRACT(epoch FROM t1.дата_начало)), 60) as время_эпоха " 
        " from акции_рф.t_m_1 as t1 "
        " left join справочники.t_securities_расширенный as t2 "
        "     on t1.secid = t2.secid"
        " where  t1.secid=$1 " 
        " order by t1.дата_начало desc limit $2::int * $3::int "; 

        
        //printf("%s\n",п_запрос_1);
        результат_запроса = PQexecParams(связь_сервер_quik, п_запрос_1, 3, NULL, 
            paramValues2, NULL, NULL, 0);   
        
        if (PQresultStatus(результат_запроса) == PGRES_TUPLES_OK) // успешное завершение команды, которая возвращает данные (PGRES_COMMAND_OK=без возврата данных)
        {         
            // возвращает число строк (кортежей) в полученной выборке (срок с результатами)
            row_number = PQntuples(результат_запроса);
            
            strcpy(адрес_структуры[i].ars_secid,  глоб_список_secid[i]);   //имя эмитента, торговый инструмент SBERP
                
            
            for (int кортеж=0; кортеж<row_number; кортеж++)
            {
                
                текущее_время=(atoi(PQgetvalue(результат_запроса, кортеж, 7))) - ((atoi(PQgetvalue(результат_запроса, кортеж, 7))) % шаг_вминутах ); //кратно шагу времени
                
                if (0==кортеж) // для самой новой точки заполняем ключевые точки по времени и обнуляем ключи = "расчеты индикаторов"
                {
                    // это ключевые точки времени, относительно которых делаются вычисления
                    
                    предшествующее_время=текущее_время - шаг_вминутах;  
                    
                    адрес_структуры[i].время_предыдущее_вминутах = предшествующее_время;
                    адрес_структуры[i].время_последнее_вминутах = текущее_время ; 
                    адрес_структуры[i].время_будущее_вминутах = текущее_время + шаг_вминутах; 
                    
                    адрес_структуры[i].нужно_обновить_индикаторы = false; 
                    адрес_структуры[i].нужно_пересчитать_индикаторы = false; 
        
                    ц_откр=atof(PQgetvalue(результат_запроса, кортеж, 2));
                    ц_макс=atof(PQgetvalue(результат_запроса, кортеж, 3));
                    ц_мин=atof(PQgetvalue(результат_запроса, кортеж, 4));
                    ц_закр=atof(PQgetvalue(результат_запроса, кортеж, 5));
                    акций_шт=atol(PQgetvalue(результат_запроса, кортеж, 6));
                }                    
                
                    // только для таймфрэйма = 1 минута заполняем ctid_последний и только для самой новой точки 
                if (0==кортеж and 1 == шаг_вминутах)
                {
                    strcpy(адрес_структуры[i].ctid_последний, PQgetvalue(результат_запроса, кортеж, 0));  
                        // последние коодинаты минуток (самое свежее время по ценам), относительно них крутятся все обновления и цен и индикаторов
                        // для некоторых инструментов завтра - этот элемен может не меняться минут 30-60!!!
                }
                
                if (предшествующее_время >= текущее_время  ) // точки отсчета 40 и 45 минут к примеру, если стало 40 и 40, то срабатывает
                {   
                    // ситуация, когда предшествующее время в теории должно равняться 25 минутмам, а по факту сделка была в 22 минуты и предшеств время = 20 минут вместо 25!
                    предшествующее_время=текущее_время - шаг_вминутах;  
                    
                    // обнуляем все интервальные переменные. 
                    ц_откр=atof(PQgetvalue(результат_запроса, кортеж, 2));
                    ц_макс=atof(PQgetvalue(результат_запроса, кортеж, 3));
                    ц_мин=atof(PQgetvalue(результат_запроса, кортеж, 4));
                    ц_закр=atof(PQgetvalue(результат_запроса, кортеж, 5));
                    акций_шт=atol(PQgetvalue(результат_запроса, кортеж, 6));

                    создали_точек =создали_точек +1;
                    if (создали_точек > max_poit) 
                    {
                        кортеж=row_number+10;
                        break;
                    }
                } // select ctid, secid, open, high, low, close, акций_шт, "
                else
                {
                        // считаем промежуточные значения. идем в обратную сторону поэтому наоборот закр и открытие
                    ц_откр=atof(PQgetvalue(результат_запроса, кортеж, 2));
                    ц_макс=(ц_макс > atof(PQgetvalue(результат_запроса, кортеж, 3))) ? ц_макс : atof(PQgetvalue(результат_запроса, кортеж, 3)) ;
                    ц_мин=(ц_мин   < atof(PQgetvalue(результат_запроса, кортеж, 4))) ? ц_мин  : atof(PQgetvalue(результат_запроса, кортеж, 4)) ;
                    //ц_закр=atof(PQgetvalue(результат_запроса, кортеж, 5));
                    акций_шт=акций_шт + atol(PQgetvalue(результат_запроса, кортеж, 6));
                }
                    // цены, но данные из БД получены в обратном порядке, т.к заранее неизвестно сколько реальных точек с данными придёт
                    // поэтому данные сохраняем на каждом цикле
                адрес_структуры[i].ard_ц_откр[max_poit-создали_точек] = ц_откр;  
                адрес_структуры[i].ard_ц_макс[max_poit-создали_точек] = ц_макс;
                адрес_структуры[i].ard_ц_мин[max_poit-создали_точек] =  ц_мин;
                адрес_структуры[i].ard_ц_закр[max_poit-создали_точек] = ц_закр;
                адрес_структуры[i].ari_акций_шт[max_poit-создали_точек] = акций_шт;
                адрес_структуры[i].ari_время_эпохи_вминутах[max_poit-создали_точек] = текущее_время; 
                адрес_структуры[i].доступно_срезов_цен = создали_точек;           // кол-во срезов времени (при норме 230 может оказаться всего 156)
            }        
        }
        else if (PQresultStatus(результат_запроса) != PGRES_TUPLES_OK)
        {
            PQsetErrorContextVisibility(связь_сервер_quik,  PQSHOW_CONTEXT_ALWAYS);
            PQsetErrorVerbosity(связь_сервер_quik,  PQERRORS_VERBOSE);
            char er_msg[5000]="# ";
            strcat(er_msg, PQerrorMessage(связь_сервер_quik));  // ОДИНАКОВО!!! = strcat(er_msg, PQresultErrorMessage(результат_запроса)); 
            strcat(er_msg, " ");
            
            fо_текст_ошибки(er_msg, -40);    
            printf("\t ОШИБКА:  %s\n", er_msg); 
        }
        PQclear(результат_запроса); 
        
        fс_автопауза_вциклах();
    }
    
    if (5==шаг_вминутах)
    {
        //fф_сообщ_тесты_срезов_цен("m5", "GAZP", 20);
    }
    
    return 0;
}
#endif










