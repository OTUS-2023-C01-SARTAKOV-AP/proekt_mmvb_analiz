#include <stdio.h> 
#include <stdlib.h> 
#include <string.h>
#include <wctype.h> 
#include <wchar.h> 
#include <time.h> 
/* #include <libpq-fe.h>   // есть /usr/include/postgresql/ */
#include <ctype.h>
#include <iso646.h>
#include <stdbool.h>
#include <uchar.h>  //  /usr/include/uchar.h
#include <locale.h>
#include <math.h>
#include <threads.h> 
#include <unistd.h> // для sleep() read()
#include <errno.h> // return EXIT_SUCCESS; 


#include "глобальные_переменные.h" 
#include "системные_функции.h" 
#include "extern_активация.h"



// тестовая запись в лог файл. Возможно, что запись в данную директорию запрещена или что данный файл имеет урезанные права
int fф_логфайл_тест_записи(void)
{
    
    errno = 0;	
    FILE *лог_файл = fopen(глоб_логфайл_путь, "a");
    
    int error_num = errno;
    
    if (лог_файл == NULL) 
    {        
            //  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        locale_t locale = newlocale(LC_ALL_MASK, "ru_RU.UTF-8", (locale_t) 0);
        char* ошибка=strerror_l(error_num, locale); 
        
        if (1 == глоб_режим_тестов)
        {
            fprintf(stderr, "\nFile : %s \nLine : %d \nCurrent function : %s() \nFailed function : %s() \nError message : %s\n", 
                                __FILE__,        __LINE__,       __func__,              "fopen",                  ошибка);
                    // File : /home/postgres/Документы/_отдельные_программы_си/001_demon_нагрузка_cpu/demon_нагрузка_cpu/файлы_внешние/файлы_действия.c 
                    // Line : 58 
                    // Current function : f_логфайл_тест_записи() 
                    // Failed function : fopen() 
                    // Error message : Нет такого файла или каталог
        }
        else
        {
            fprintf(stderr, "f_логфайл_тест_записи. Сообщение об ошибке (%d) : %s\n", error_num, ошибка);
            printf("%s \n", ошибка);
                    // Error message (2)  : Нет такого файла или каталога
                    // Нет такого файла или каталога 
        }

        freelocale(locale); 
        fclose(лог_файл);
        
        return -1;
    }
    
    fс_дата_время_текст_значение();

    fputs(глоб_время_как_текст,  лог_файл);
    fputs("Тестовая запись проверки корректности пути лог.файла. \n", лог_файл);
    fclose(лог_файл);
            
    return 0;
}



// Запись ошибки в предопределённый ранее лог.файла (учет ошибок, действий)
int fф_логфайл_запись_сообщения(const char* текст_сообщения)
{
    // просто записываем в журнал сообщение, что пришло.
    // Пришедшее сообщение уже должно быть полностью отформатировано для записи, то есть иметь временную метку и все необходимые поля.

    long int размер_логжурнала=0;
    
    errno = 0;	
    FILE *лог_файл = fopen(глоб_логфайл_путь, "a");
    
    int error_num = errno;
    
    if (лог_файл == NULL) 
    {        
        locale_t locale = newlocale(LC_ALL_MASK, "ru_RU.UTF-8", (locale_t) 0);
        char* ошибка=strerror_l(error_num, locale);
        fprintf(stderr, "f_логфайл_тест_записи. Сообщение об ошибке (%d) : %s\n", error_num, ошибка);
        printf("%s \n", ошибка);

        freelocale(locale); 
        fclose(лог_файл);
        
        return 0;
    }
    
    
    // определить его размер если более 30 кб - то обнуляем его (создаём новый файл)
    размер_логжурнала = fс_размер_логжурнала();
    if (размер_логжурнала > 30*1000)
    {
        fclose(лог_файл);
        fс_пауза_вработе_программы(0, 0.6);
        
        FILE *лог_файл = fopen(глоб_логфайл_путь, "w");
        fс_пауза_вработе_программы(0, 0.4);
    }

    fputs(текст_сообщения, лог_файл);
    fputs("\n", лог_файл);
    fclose(лог_файл);
    
    return 0;
}







// Вывод сообщения о текущих котировках с учетом таймфрэйма и акции и нагрузки ПК (отслеживать, что код работает)!
int fф_сообщ_текущие_срезы_цен(const char* таймфрэйм, const char* secid)
{
    int номер_secid;
    int номер_таймфрэйма=0;
    int срезов_цен=глоб_об_ключи_запуска.точек_вданных;
    volatile struct таймфрэйм_шаблон *адрес_структуры;
    
    for (int i2=0; i2<глоб_список_secid_штук; i2++)
    {
        if (0==strcmp(глоб_список_secid[i2], secid)) // "GAZP"
        {
            номер_secid=i2;
            break;
        }
    }
     
    for (int tf=0; tf<глоб_об_таймфрэймы_описание.всего_шт; tf++)
    {
        if (0==strcmp(глоб_об_таймфрэймы_описание.список_имен[tf], таймфрэйм)) 
        {
            номер_таймфрэйма=tf;
            break;
        }
    }
    
        // это сложная структура, которая является массивом из структур (указатель на МАССИВ из СТРУКТУР)
    адрес_структуры = глоб_об_таймфрэймы_описание.адрес_в_памяти[номер_таймфрэйма]; // 10 для м30    
    
    char время_как_текст[50]=""; 
    strcpy(время_как_текст, " ");
    time_t число_сек = 60 * (адрес_структуры[номер_secid].ari_время_эпохи_вминутах[срезов_цен-1]);
    struct tm об_время;
    gmtime_r(&число_сек, &об_время);

    char* dw[7]={"вс","пн","вт","ср","чт","пт","сб" };

    strftime(время_как_текст, 40, "%H:%M(", &об_время);
    strcat(время_как_текст, dw[об_время.tm_wday]);
    strcat(время_как_текст, ")");
    
    printf( "%s/%s", таймфрэйм, secid);   
    printf( " %s:", время_как_текст);  // самое свежее время из анализируемой структуры (самая последняя точка)
    printf( " откр %4.2lf", адрес_структуры[номер_secid].ard_ц_откр[срезов_цен-1]);
    printf( " макс \033[32m↑%4.2lf\033[0m", адрес_структуры[номер_secid].ard_ц_макс[срезов_цен-1]);
    printf( " мин \033[31m↓%4.2lf\033[0m", адрес_структуры[номер_secid].ard_ц_мин[срезов_цен-1]);
    printf( " закр %4.2lf", адрес_структуры[номер_secid].ard_ц_закр[срезов_цен-1]);
    printf( " оборот %li", адрес_структуры[номер_secid].ari_акций_шт[срезов_цен-1]); 
    printf(" \033[1mCPU: %3.1f%%, CPU_t: %3.1f °C\033[22m\n", глоб_об_нагрузка_оперсист.cpu_експотенц_средн, глоб_об_нагрузка_оперсист.cpu_t_експотенц_средн);
    // На компьютерах с ОС Linux знак можно получить, набрав Composeoo или ⇧ Shift+Ctrl+U и набрав b0↵ Enter после u. !!!!!!!!!!!!
    // Юникод	U+00B0   !!!!!!!!!!!
    // https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B5%D0%BB%D0%BA%D0%B0_(%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB)
    return 0;
}








// Вывод проверочных тестовых сообщений о ценах
int fф_сообщ_тесты_срезов_цен(const char* таймфрэйм, const char* secid, int свежих_точек_шт)
{
    int номер_secid;
    int номер_таймфрэйма=0;
    int срезов_цен=глоб_об_ключи_запуска.точек_вданных;
    struct таймфрэйм_шаблон *адрес_структуры;
    
    for (int i2=0; i2<глоб_список_secid_штук; i2++)
    {
        if (0==strcmp(глоб_список_secid[i2], secid)) // "GAZP"
        {
            номер_secid=i2;
            break;
        }
    }
     
    for (int tf=0; tf<глоб_об_таймфрэймы_описание.всего_шт; tf++)
    {
        if (0==strcmp(глоб_об_таймфрэймы_описание.список_имен[tf], таймфрэйм)) // "m30"
        {
            номер_таймфрэйма=tf;
            break;
        }
    }
    
        // это сложная структура, которая является массивом из структур (указатель на МАССИВ из СТРУКТУР)
    адрес_структуры = глоб_об_таймфрэймы_описание.адрес_в_памяти[номер_таймфрэйма]; // 10 для m30    
    
    char текст[50]=""; 
    char время_как_текст[50]=""; 
    
    struct tm об_время;    
    char* dw[7]={"вс","пн","вт","ср","чт","пт","сб" };
    char* месяц[12]={"янв","фев","март","апр","май","июнь","июль","авг","сент","окт","нояб","дек"};
    printf( "\n");
    
    for (int i4=1; i4 <= свежих_точек_шт; i4++)
    {
        strcpy(текст, "");
        strcpy(время_как_текст, "");
        
        time_t число_сек = 60 * (адрес_структуры[номер_secid].ari_время_эпохи_вминутах[срезов_цен-i4]);
        gmtime_r(&число_сек, &об_время);
        
        if (номер_таймфрэйма>=18)
        {
            strftime(время_как_текст, 40, "%Y.%m.%d", &об_время);
        }
        else if (номер_таймфрэйма<11)
        {
            strftime(время_как_текст, 40, "%H:%M(", &об_время);
            strcat(время_как_текст, dw[об_время.tm_wday]);
            strcat(время_как_текст, ")");
        }
        else 
        {
            sprintf(текст, "%i", об_время.tm_mday);
            strcat(текст, ".");
            strcat(текст, месяц[об_время.tm_mon]);
            strftime(время_как_текст, 40, " %H:%M", &об_время);
        }
        strcat(текст, время_как_текст);

        printf( "%s[%i]%s", таймфрэйм, срезов_цен-i4, secid);   
        printf( " %s:", текст);  // самое свежее время из анализируемой структуры (самая последняя точка)
        printf( " откр %4.2lf", адрес_структуры[номер_secid].ard_ц_откр[срезов_цен-i4]);
        printf( " макс \033[32m↑%4.2lf\033[0m", адрес_структуры[номер_secid].ard_ц_макс[срезов_цен-i4]);
        printf( " мин \033[31m↓%4.2lf\033[0m", адрес_структуры[номер_secid].ard_ц_мин[срезов_цен-i4]);
        printf( " закр %4.2lf", адрес_структуры[номер_secid].ard_ц_закр[срезов_цен-i4]);
        printf( " %8li шт\n", адрес_структуры[номер_secid].ari_акций_шт[срезов_цен-i4]); 
    }
    return 0;
}




