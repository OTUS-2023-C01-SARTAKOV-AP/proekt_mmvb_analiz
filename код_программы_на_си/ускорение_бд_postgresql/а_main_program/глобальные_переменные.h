// смотри в папке с main.c инструкцию по офорлмению кода


// В документации объясняется:
// Какую задачу решает  каждый алгоритм
// Какие входные значения допустимы
// Что возвращает модуль\функция\программа
// Так же содержит инфу о гиперпараметрах.

// f_xxx() = функция
// ari_xxx = массив из целых чисел (обычно 64 битные)
// arui_xxx = массив из unsigned integer (из целых беззнаковых чисел, так же обычно 64 бита)
// ard_xxx = массив из double (дробных чисел) float не применяю, т.к память все равно занимают как double
// ars_xxx = строка символов (массив из char)
// arws_xxx = строка символов wchar (массив из широких символов char, типа русский текст и команды нужны для широких символов)
// arук_xxx = массив из указателей. В нём содержатся предложения переменной длины. 
// 
// об_xxx = Объект, класс, он же ООП -> структура чего либо
// ук_xxx = указатель, адрес в памяти ссылающийся на начало чего либа
// ук_ук_ххх (укук_xxx) = указатель на адрес в памяти, который ссылается на другой указатель = **массив_указателей_на_текст



#ifndef ГЛОБАЛЬНЫЕ_ПЕРЕМЕННЫЕ_H

#include <libpq-fe.h> 

#define ГЛОБАЛЬНЫЕ_ПЕРЕМЕННЫЕ_H
#define СТРОКА_63 63  
#define СТРОКА_255 255
  
  
  
  
    // структура с описанием по  тафмфрэймам, с которыми работает код
    //extern struct таймфрэймы_описание глоб_об_таймфрэймы_описание; 
struct таймфрэймы_описание {
    unsigned short int всего_шт; // =11, сколько всего таймфрэймов есть для работы (одинаковое кол-во для всех)
    char список_имен[11][8]; //char** список_имен; без явного указания кол-ва, иначе нужно назначать ровно N штук!!! char* список_имен[11];
    int шаг_вминутах[11]; // шаг в минутах для минуток 
    struct таймфрэйм_шаблон *адрес_в_памяти[11]; // указатель , адрес структуры в оперативной памяти
    bool arb_список_для_обновлен_бд[350]; 
        // список из 350  ключей, порядок в которых соответствует порядку акций в char глоб_список_secid[350][6].
        // если поле = true (1), то по этому эмитенту было обновление по м1 
        // и один раз в 3-5 секунд, этот список проверяется. 
        // Если там  было обновление (поле=true), то в БД скидываются новые данные, точки, 
        // для вывода самой свежей информации при построении графиков с торговыми индикаторами
        // этот ключ независим от других (ведь можно было бы просто считывать обновления по м1), 
        // но этот параметр считается в самом конце цила и с переменным временным лагом 
        // и при приходе к нему все индикаторы, указывающие что было обнвление уже сбрасываются в "НЕТ/НЕ_БЫЛО" 
        
}; 


    
    // Первичные настройки работы программы (нагрузка процессора, 
    // температура процессора, оперативная память, жесткий диск ...
struct ключи_запуска { 
    char arws_db[СТРОКА_63];        // имя БД в Постгрес
    char arws_schema[СТРОКА_63];    // имя схемы в БД PostgreSQL            // wchar_t
    char arws_table[СТРОКА_63];     // имя таблицы
    char arws_host[СТРОКА_63];      // адрес в сети или localhost
    char порт_бд[СТРОКА_63];        // порт
    char arws_user[СТРОКА_63];      // имя пользователя, его учетное имя от которой делается доступ к БД PostgresSQL
    char arws_пароль[СТРОКА_63];    // пароль пользователя
    int интервал_обновл_сек;        // частота запросов нагрузки по ПК.
    int вывод_помощи;               // выводит инструкцию по ключам (help справка)
    int тест_сообщ;                 // эта строка выводит сообщения о переданных ключах (если активирован данный режим)
    char arws_логфайл_путь[СТРОКА_255]; // путь, где расположен журнал ошибок и действий
    int точек_вданных;              // 230 точек с данными в каждом таймфрэйме (их может быть меньше, но не больше этого числа
    int независимых_потоков;        // 1 или указанное число. Если более 100, то ограничений нет 
            // и равно максимально возможному число, зашитому в коде программы, с учётом нагрузки на ПК
};



    // структура нагрузки системы - значения, которые мы контролируем и передаём в БД
struct нагрузка_оперсист { 
    double cpu_now;                 // нагрузка на процессор сейчас
    double cpu_експотенц_средн;   // експотенциальная средняя (как 66% старых+34% новых) нагрузки процессора
    unsigned long int cpu_тики_нагрузок_старые; // нужны для расчетов
    unsigned long int cpu_тики_всего_старые;    // нужны для расчетов
    
    double cpu_t_now;                  //температура сейчас
    double cpu_t_експотенц_средн;     // експотенциальная средняя (как 66% старых+34% новых) используемой температуры в градусах цельсия 

    int всего_ядер;
};






// 1.1) сперва мы в бесконечном цикле в первом блоке запрашиваем все точки с ценами по м1 из БД с сегодняшними/текущими котировками, 
// 1.3) Если было обновление цены по м1, то делаем пометку в таймфрэйм_m1 что цены изменились.
// ЛИМИТ не более 0,3 сек иначе распараллеливаем. Если блок по изменению цен был распараллелен, то ждем окончания работы всех его потоков.
// 2.1) Запуск ВСЕГДА распаралеленных потоков (один поток на оин таймфрэйм) расчетов индикаторов по акциям (по списку, по которым были изменения).
// 2.2) Ждем их окончания. 
// 3.1) Потом блок пересчёта индикаторов снимает метки из таймфрэйм_хх о том, что нужно обновить индикаторы (оба указателя - ставит его в false).
// 3.2) Запуск этих двух блоков заново


    // глобальная структура по таймфрэйму=м1 и разным торговым инструментам (акциям)
    // размер примерно 8400 на 1 элемент (secid)
struct таймфрэйм_шаблон {
    char ars_secid[6];                      //SBERP
    short int доступно_срезов_цен;       // кол-во срезов времени (при норме 230 может оказаться всего 156)
    double ard_ц_откр[230];              // задаём как 230, но по факту может быть меньше
    double ard_ц_мин[230];
    double ard_ц_макс[230];
    double ard_ц_закр[230];
    long int ari_акций_шт[230];              // сделок в лотах (в одном лоте может быть 100 акций)  !!! 
    int ari_время_эпохи_вминутах[230];      // время в минутах с 1970 (как эпоха, только в минутах)!!!! все точки картные 60 секундам!

    char ctid_последний[16];                // номер  служебной записи строки ctid в БД в таблице (страница, строка) = (1025,98)
            // ctid_последний по сегодняшим котировкам м1 из temp таблицы (если он не изменился, то обновлений не делаем)
    int время_предыдущее_вминутах; 
    int время_последнее_вминутах;
    int время_будущее_вминутах;             // для срабатывания условия, что появилась новая запись
    bool нужно_обновить_индикаторы;         // true false  было ли обновление по данному secid/акции (цены) изменение, без добавления нового среза по времени
        // Если да, то по нему делается перерасчет индикаторов, если нет, то перерасчет не делаем. 
    bool нужно_пересчитать_индикаторы;      // когда у нас появилась новая точка по шкале времени - 
                // нужно будет заново пересчитать ВСЕ индикаторы по этому таймфрэйму по этой бумаге
}; 



    // структура параметров таймфрэймов => нужна для передачи данных внутри нового потока указанной функции (наполнение таймфрэймов)
typedef struct  { 
    char ars_имя_таймфрэйм[8];      // m10 для справки, не более того
    int номер_таймфрэйма;           // 5  можно вичислить глобальный адрес структуры для работы  = struct таймфрэйм_шаблон *адрес_структуры;
    int шаг_вминутах;               // 10
    PGconn* связь_сервер_quik;  
} ПОТОКИ_объект_Timeframe;





#endif




