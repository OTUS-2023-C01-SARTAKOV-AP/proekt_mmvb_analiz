
// смотри в папке с main.c инструкцию по офорлмению кода


// В документации объясняется:
// Какую задачу решает  каждый алгоритм
// Какие входные значения допустимы
// Что возвращает модуль\функция\программа
// Так же содержит инфу о гиперпараметрах.

 
#define СТРОКА_255 255


    // структура с описанием  по  тафмфрэймам, с которыми работает код
struct таймфрэймы_описание глоб_об_таймфрэймы_описание; 


    // глобальная строка, куда кидается фремя в формате       2023.10.30 11:26:43, понедельник 
char глоб_время_как_текст[50]=""; // значения назначаются ТОЛЬКО в main.c


    // глобальный список акций ММВБ (secid). Позволяет делать быстрый доступ внутри любой структуры по таймфрэймам 
    // т.к. порядок во всех структурах ОДИНАКОВЫЙ и равен этому самому списку. С урсской кодировкой не другит (не приспособлена)
char глоб_список_secid[350][6]={{'n','o','\0'},{"no"},[119]={"no"}, [199]={"no"}};


    // длина глобальный список акций ММВБ (secid) в штуках
int глоб_список_secid_штук=350;


    // глобальная переменная путь к журналу ошибок/действий оно же "arws_логфайл_путь" из структуры "ключи_запуска"
char глоб_логфайл_путь[СТРОКА_255]=""; // значения назначаются ТОЛЬКО в main.c


    // глобальная переменная оно же "тест_сообщ" из структуры "ключи_запуска".
    // выводит многие сообщения в терминал. Для отслеживания работоспособности.
    // В боевом режиме почти ничего из тестового режима не выводится.
int глоб_режим_тестов=0; // значения назначаются ТОЛЬКО в main.c


    // импорт файла конфигурации. Первичные настройки работы программы (нагрузка процессора, 
    // температура процессора, оперативная память, жесткий диск ...
struct ключи_запуска глоб_об_ключи_запуска;


    // структура нагрузки системы - значения, которые мы контролируем и передаём в БД
volatile struct нагрузка_оперсист глоб_об_нагрузка_оперсист; 


    // глобальный указатель на структуру по таймфрэйму = м1 и разным торговым инструментам (акциям)
    // размер примерно 8400 на 1 элемент (secid)
volatile struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m1;
    //printf("размер памяти для всей структуры gl_ar_структ_таймфрэйм_m1: \033[1m%i\033[22m\n", malloc_usable_size(gl_ar_структ_таймфрэйм_m1)); = 0 bite
volatile struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m2;
volatile struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m3;
volatile struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m4;
volatile struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m5;
volatile struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m6;
volatile struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m10;
volatile struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m12;
volatile struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m15;
volatile struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m20;
volatile struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m30;


    // глобальная переменная коэффициент задержки в штуках, кратных 0.0001 сек. Так при 0 получаем задерждку в 0, а при 2=0,0002 сек
    // нужно, когда нагрузка или тепрература ПК превысит допстимые знаяения (снижаем нагрузку на ПК)
volatile int глоб_коэффиц_паузы=1; 

 
