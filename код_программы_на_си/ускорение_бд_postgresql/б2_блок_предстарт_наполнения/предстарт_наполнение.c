#include <stdio.h> // perror()
#include <stdlib.h> 
#include <string.h>
#include <wctype.h> 
#include <wchar.h> 
#include <time.h> 
#include <libpq-fe.h>   // есть /usr/include/postgresql/ */
#include <ctype.h>
#include <iso646.h>
#include <stdbool.h>
#include <uchar.h>  //  /usr/include/uchar.h
#include <locale.h>
#include <math.h>
#include <threads.h> 
#include <unistd.h> // для sleep() read()
#include <errno.h> // return EXIT_SUCCESS; 
#include <sys/stat.h>
#include <malloc.h> // malloc_usable_size()



#include "глобальные_переменные.h" 
#include "нагрузка_пк.h" 
#include "входные_данные.h" 
#include "ошибки_обработка.h" 
#include "системные_функции.h"
#include "файлы_действия.h"
#include "extern_активация.h"
#include "запросы_к_бд.h" 





int fб2_предстартов_наполнение(void)
{
    int ошибка_номер=0;
    
    strcpy(глоб_логфайл_путь, глоб_об_ключи_запуска.arws_логфайл_путь); 
    глоб_режим_тестов = глоб_об_ключи_запуска.тест_сообщ; 
    
    
    // ========= проверка на предмет работы с лог файлом (можно ли в него писать) и тестовые записи =======
    // 
    ошибка_номер = fф_логфайл_тест_записи(); // проверка записи в лог.журнал
    
    if (ошибка_номер != 0)
    {
        printf("\n Лог файл по пути: '%s'  \n невозможно создать или использовать уже существующий.\n", глоб_логфайл_путь);
        printf("\n Принудительный выход из работы программы. \n");
        return -1; 
    }
    else
    {
        if (1 == глоб_режим_тестов) 
        {
             printf("\n Проверен путь для записи в журнал сообщений: \033[1m '%s' \033[22m \n"
                    " Проблем с его использованием нет. \n", глоб_логфайл_путь );
        }        
        long int размер_логжурнала = fс_размер_логжурнала(); 
        char стр1[255]=""; 
        char стр2[128]=""; 
        strcpy(стр1, глоб_время_как_текст); 
        sprintf(стр2, " До сообщения, Размер журнала был равен %li байт.", размер_логжурнала);
        strcat(стр1, стр2);     
        
        ошибка_номер = fф_логфайл_запись_сообщения(стр1);
    }
    // =================================================================================  
    
    
    
    // ====== блок первичного наполнения данными о процессоре, его загрузке и температуре в цельсиях ======
    //              наполнение глобальных структур и массивов
    //
    глоб_об_нагрузка_оперсист.cpu_t_експотенц_средн = 0;    
    глоб_об_нагрузка_оперсист.cpu_тики_нагрузок_старые = 0;
    глоб_об_нагрузка_оперсист.cpu_тики_всего_старые = 0;
       
    глоб_об_нагрузка_оперсист.всего_ядер = fб1_cpuinfo();    // прописывает количество ядер (реальные+вирутальные) 
    fс_сообщение_о_нагрузке();
    printf("На ПК ядер CPU, включая виртуальные ядра = %i шт. \n", глоб_об_нагрузка_оперсист.всего_ядер);
    sleep(1);                            // Если менее 1 секунды, то возможна блокировка при запросах системных файлов
    
    глоб_об_ключи_запуска.точек_вданных=230; 
    глоб_об_таймфрэймы_описание.всего_шт=11;
    
    
    // обнуляем перечнь, список акций, по которому нужно переслать новые /свежие данные в БД
    int i_длина = (sizeof глоб_об_таймфрэймы_описание.arb_список_для_обновлен_бд) / (sizeof глоб_об_таймфрэймы_описание.arb_список_для_обновлен_бд[0]); 
    for (int i=0; i < i_длина; i++)
    {
        глоб_об_таймфрэймы_описание.arb_список_для_обновлен_бд[i]=false;
    }
    
    /* ЕДИНОРАЗОВЫЙ ВАРИАНТ!!!! ПОВТОРНО К ЭТИМ УКАЗАТЕЛЯМ ОБРАТИТЬСЯ НЕЛЬЗЯ!!!!
    глоб_об_таймфрэймы_описание.список_имен=(char *[]){"m1","m2","m3","m4","m5","m6","m10","m12","m15","m20","m30"}; */
    strcpy(глоб_об_таймфрэймы_описание.список_имен[0], "m1");
    strcpy(глоб_об_таймфрэймы_описание.список_имен[1], "m2");
    strcpy(глоб_об_таймфрэймы_описание.список_имен[2], "m3");
    strcpy(глоб_об_таймфрэймы_описание.список_имен[3], "m4");
    strcpy(глоб_об_таймфрэймы_описание.список_имен[4], "m5");
    strcpy(глоб_об_таймфрэймы_описание.список_имен[5], "m6");
    strcpy(глоб_об_таймфрэймы_описание.список_имен[6], "m10");
    strcpy(глоб_об_таймфрэймы_описание.список_имен[7], "m12");
    strcpy(глоб_об_таймфрэймы_описание.список_имен[8], "m15");
    strcpy(глоб_об_таймфрэймы_описание.список_имен[9], "m20");
    strcpy(глоб_об_таймфрэймы_описание.список_имен[10], "m30");         
    
    глоб_об_таймфрэймы_описание.шаг_вминутах[0]=1;
    глоб_об_таймфрэймы_описание.шаг_вминутах[1]=2;
    глоб_об_таймфрэймы_описание.шаг_вминутах[2]=3;
    глоб_об_таймфрэймы_описание.шаг_вминутах[3]=4;
    глоб_об_таймфрэймы_описание.шаг_вминутах[4]=5;
    глоб_об_таймфрэймы_описание.шаг_вминутах[5]=6;
    глоб_об_таймфрэймы_описание.шаг_вминутах[6]=10;
    глоб_об_таймфрэймы_описание.шаг_вминутах[7]=12;
    глоб_об_таймфрэймы_описание.шаг_вминутах[8]=15;
    глоб_об_таймфрэймы_описание.шаг_вминутах[9]=20;
    глоб_об_таймфрэймы_описание.шаг_вминутах[10]=30;
       
    
    printf("\n========================================================\n"
    " Максимум точек в цене: %i,    Таймфрэймов штук: %i,     [8]==%s \n",
    глоб_об_ключи_запуска.точек_вданных, глоб_об_таймфрэймы_описание.всего_шт,  глоб_об_таймфрэймы_описание.список_имен[8]); 
    // ================================================================================================ 
        
    
    
    
    


    

    

    
    
    
    // =======================================   Запросы и БД   Наполнение данными: список акций, активация соединений   ================================
    //        
    
    //struct таймфрэйм_шаблон *адрес_структуры; // временный указатель на массив из структур по указанному таймфрэйму, который передайтся во внешние функции 
    time_t время_индикатор;
    int спешим_на_сек; // насколько секунд локальное время (Москва +2/+3 часа) больше времени UTC (+0)
       
    struct timespec время_начало;
    timespec_get(&время_начало, TIME_UTC);
    
    int номер_старт=0; // включая его !!!
    int номер_конец=10; // включая его !!!
    int поток_цикл = 0; // для вычислений номера тайфмрэйма в глобальной структуре для сличния потока = thrd_join(***) т.к. начало и конец везде разный и часть параметров нужно проигнорировать
    int смещение=0;
       
        // устанавливаем соединение с БД и назначаем этот указатель глобальной переменной (переназначаем его)
    PGconn* связь_сервер_quik = fбд_соединение_бд(); // = 0.04-0.055 сек на установку каждого соединения и это уже 1,2 сек на 30 таймфрэймов!!!
    
    if (PQstatus(связь_сервер_quik) != CONNECTION_OK)
        {  return -10;  }    
        
        // формирует список secid для последующей работы
    ошибка_номер = fбд_получить_список_secid(связь_сервер_quik); 
    
        if (ошибка_номер !=0) 
        {
            printf("Описание ошибки смотри в текстовом файле логов по адресу: \n\t\t%s\n", глоб_логфайл_путь);
            PQfinish(связь_сервер_quik);
        }
        else
        {
            printf("Всего для последующего анализа подходит \033[1m %i инструментов \033[22m \n", глоб_список_secid_штук);
            printf("Тестовая проверка списка акций:\033[1m 3=%s\t 40=%s\t 130=%s \033[22m\n", глоб_список_secid[3], глоб_список_secid[40], глоб_список_secid[130]);
        }
    
    // ================================================================================================================================== 
    
    
    
    




    // ===========================   Запросы и БД   Наполнение первичными данными по таймфрэймам m1-m30   ================================
    //  
        struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m1 = calloc(глоб_список_secid_штук, sizeof(struct таймфрэйм_шаблон)); //malloc(12 * sizeof(struct таймфрэйм_m1));
    глоб_об_таймфрэймы_описание.адрес_в_памяти[0]=gl_ar_структ_таймфрэйм_m1;
    printf("размер памяти на 1 элемент    \033[1mтаймфрэйм_m1:\033[22m %li     для всей структуры таймфрэйм_шаблон: \033[1m%lu\033[22m\n", 
            sizeof(struct таймфрэйм_шаблон), (size_t) malloc_usable_size(gl_ar_структ_таймфрэйм_m1));
    printf("\n\n");
    
        struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m2 = calloc(глоб_список_secid_штук, sizeof(struct таймфрэйм_шаблон)); 
    глоб_об_таймфрэймы_описание.адрес_в_памяти[1]=gl_ar_структ_таймфрэйм_m2;
    
        struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m3 = calloc(глоб_список_secid_штук, sizeof(struct таймфрэйм_шаблон)); 
    глоб_об_таймфрэймы_описание.адрес_в_памяти[2]=gl_ar_структ_таймфрэйм_m3;
    
        struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m4 = calloc(глоб_список_secid_штук, sizeof(struct таймфрэйм_шаблон)); 
    глоб_об_таймфрэймы_описание.адрес_в_памяти[3]=gl_ar_структ_таймфрэйм_m4;
    
        struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m5 = calloc(глоб_список_secid_штук, sizeof(struct таймфрэйм_шаблон)); 
    глоб_об_таймфрэймы_описание.адрес_в_памяти[4]=gl_ar_структ_таймфрэйм_m5;
    
        struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m6 = calloc(глоб_список_secid_штук, sizeof(struct таймфрэйм_шаблон)); 
    глоб_об_таймфрэймы_описание.адрес_в_памяти[5]=gl_ar_структ_таймфрэйм_m6;
    
        struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m10 = calloc(глоб_список_secid_штук, sizeof(struct таймфрэйм_шаблон)); 
    глоб_об_таймфрэймы_описание.адрес_в_памяти[6]=gl_ar_структ_таймфрэйм_m10;
    
        struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m12 = calloc(глоб_список_secid_штук, sizeof(struct таймфрэйм_шаблон)); 
    глоб_об_таймфрэймы_описание.адрес_в_памяти[7]=gl_ar_структ_таймфрэйм_m12;    
    
        struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m15 = calloc(глоб_список_secid_штук, sizeof(struct таймфрэйм_шаблон)); 
    глоб_об_таймфрэймы_описание.адрес_в_памяти[8]=gl_ar_структ_таймфрэйм_m15;  
  
        struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m20 = calloc(глоб_список_secid_штук, sizeof(struct таймфрэйм_шаблон)); 
    глоб_об_таймфрэймы_описание.адрес_в_памяти[9]=gl_ar_структ_таймфрэйм_m20;
    
        struct таймфрэйм_шаблон *gl_ar_структ_таймфрэйм_m30 = calloc(глоб_список_secid_штук, sizeof(struct таймфрэйм_шаблон)); 
    глоб_об_таймфрэймы_описание.адрес_в_памяти[10]=gl_ar_структ_таймфрэйм_m30; 


        // если время больше 09-59-00, то расчёт минуток пропускаем, т.к они считаются 14 секунд здесь 
        // а затем еще раз считаются в Экстренном старте (но только минутки!!!)
    спешим_на_сек = fс_разница_сек_часовых_поясов(); 
    время_индикатор =  (time(NULL) - time(NULL)%(24*3600)) + (time_t)(10*3600 - 1*60 - спешим_на_сек); // > 09-59-00 по местному времени
    
    if (1==1) //if (time(NULL) <= время_индикатор)
    {        
        thrd_t потоки_расчётов[12]; //  выделяем 12 независимых потоков для расчётов (12 ядр, возможно будут изменения)
        printf(" ГЛОБАЛЬНОЕ ограничение потоков = %i \n", глоб_об_ключи_запуска.независимых_потоков);
        
        // заполнение первичными (прдтороговыми данными по ценам) для индикаторов m1-m30 для выбранных 170 акций
        номер_старт=0; // включая его !!!
        номер_конец=10; // включая его !!!
        поток_цикл = 0; // для вычислений 
        смещение = номер_старт;
        
        for (int номер=номер_старт; номер <= номер_конец; )
        {     
            // создаём потоки с учетом указанного количества ветвлений
            ПОТОКИ_объект_Timeframe параметры[глоб_об_ключи_запуска.независимых_потоков];
            
            for (int поток_номер=0; поток_номер<глоб_об_ключи_запуска.независимых_потоков; поток_номер ++)
            {
                if (номер > номер_конец)  {break;} // для минуток максимум 11 (10 c нуля) периодов 
                
                strcpy(параметры[поток_номер].ars_имя_таймфрэйм, глоб_об_таймфрэймы_описание.список_имен[номер]);
                параметры[поток_номер].номер_таймфрэйма = номер;
                параметры[поток_номер].шаг_вминутах = глоб_об_таймфрэймы_описание.шаг_вминутах[номер];
                параметры[поток_номер].связь_сервер_quik = связь_сервер_quik;
                                
                //printf("[%i]    %s    &параметры = %p   \n", номер, глоб_об_таймфрэймы_описание.список_имен[номер], (void*)&параметры[поток_номер]); // [10]   m30 
                printf("[%i] имя_таймфрэйм = %s, номер_таймфрэйма = %i, шаг_вминутах = %i \n", номер, 
                        параметры[поток_номер].ars_имя_таймфрэйм, параметры[поток_номер].номер_таймфрэйма, параметры[поток_номер].шаг_вминутах);
    
                ошибка_номер = thrd_create(&потоки_расчётов[поток_номер], (thrd_start_t)fбд_предстарт_потоки_mm, ((void*)&параметры[поток_номер]) );
                if (ошибка_номер != thrd_success) 
                {
                    printf("ERORR; Ошибка создания потока № %i для периода %s не создался. Номер ошибки = %i \n", 
                        поток_номер, глоб_об_таймфрэймы_описание.список_имен[номер], ошибка_номер);
                    exit(EXIT_FAILURE); 
                }
                else  { номер ++; }
            }
               
            // теперь собираем результаты со всех потоков и продолжаем цикл далее 
            for (int поток_номер=0; поток_номер<глоб_об_ключи_запуска.независимых_потоков; поток_номер ++)
            {
                int позиция = смещение + (поток_цикл * (глоб_об_ключи_запуска.независимых_потоков) + поток_номер);
                if (позиция > номер_конец)  {break;} // иначе будет ждать несуществующие потоки и будет ошибка сегментирования
                
                printf("Ожидаем завершеня локального thrd_join №=%i из глобального = %i (%s) \n", 
                    поток_номер, позиция, глоб_об_таймфрэймы_описание.список_имен[позиция]);
                ошибка_номер = thrd_join(потоки_расчётов[поток_номер], NULL);
                if (ошибка_номер != thrd_success) 
                {
                    printf(" ERORR; Ошибка вливания потока № %i для периода %s в родительский код. Номер ошибки = %i \n", 
                        поток_номер, глоб_об_таймфрэймы_описание.список_имен[номер], ошибка_номер);
                    exit(EXIT_FAILURE);          
                }
            }
            
            поток_цикл ++;
    
            fс_пауза_вработе_программы(0, 0.001);
            fс_сообщение_о_нагрузке();
        } 

    } // for (int номер=0; номер<11; )
        
    fс_секундомер_наносек(&время_начало);
    printf("\n");
    printf("\t\tПредстартовое наполнение данными завершили \n\n");

    
    PQfinish(связь_сервер_quik); // закрытие подключения к БД и очистка памяти от подключения    
    
    return 0;
}

