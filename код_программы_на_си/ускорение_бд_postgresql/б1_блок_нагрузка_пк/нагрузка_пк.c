// Данный блок функций вычисляет каждые 0,5 сек нагрузку на ПК 
// замеры нагрузки процессора
// замеры температуры процессора
// данные нужно усреднять за 5 секунд, то есть 5 интервалов по 2,5 после чего начинается отсчет

#include <ctype.h>
#include <fcntl.h>
#include <iso646.h>
#include <locale.h>
#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <time.h>
#include <uchar.h>  //  /usr/include/uchar.h
#include <unistd.h> // для sleep() read()
#include <wchar.h>
#include <fcntl.h> // open("/proc/stat", O_RDONLY))
#include <threads.h> 
#include <stdatomic.h>


#include "глобальные_переменные.h" 
//#include "ошибки_обработка.h"
#include "extern_активация.h"



#define МАКС_ДЛИНА_СТРОКИ 256



// программа определяем стколько ядер всего у процессора в системе
// всего (реальные + виртуальные)
int fб1_cpuinfo(void)
{
    FILE *информационный_файл;
    char параметр[256];
    char символы_2[256];
    char символы_3[256];
    int всего_ядер=6;

    if((информационный_файл = fopen("/proc/cpuinfo", "r")) == NULL)    
    {
        fprintf(stdout, " Не удаётся открыть файл информации о процессоре. \n");      
    } 
    else 
    { 
        for (int i=0; i<22; i++) 
        {
            fscanf(информационный_файл, "%127s%127s%127s%*[^\n]", параметр, символы_2, символы_3);
            //printf(" '%s' === '%s' ====='%s' \n", параметр, символы_2, символы_3);
                
            if (0==strcmp("siblings", параметр)) 
            {
                всего_ядер = atoi(символы_3);
                //printf(" 107) Всего ядер = %i \n", всего_ядер);
                return всего_ядер; 
            }
            else
            {
                //printf(" 112) Всего ядер = %i \n", всего_ядер);
            }
        }
    }
    fclose(информационный_файл);
    
    return всего_ядер; 
}








// фнутренняя (скрытая) функция по определению температуры процессора по 1-му ядру (самое перове из всех)
static double sf_температура_cpu(void)
{
    FILE *информационный_файл;
    int большое_число = 0;
    double температура = 0;

        //printf(" '303) Запустили считывание температуры процессора \n");
    if ((информационный_файл = fopen("/sys/class/hwmon/hwmon5/temp1_input", "r")) == NULL)    
    {
        fprintf(stdout, " Не удаётся открыть файл информации о температуре процессоре. \n");  
        fclose(информационный_файл);   
        return 70.0;
    } 
    else 
    { 
        if (1==fscanf(информационный_файл, "%i%*[^\n]", &большое_число))
        {
            температура = большое_число/1000.0;
            //printf(" %lf \n", температура);
        }   
    }
    
    fclose(информационный_файл);   
    return температура;
}


        // функция по наполнению объекта "нагрузка операционной системы" данными по температуре первого ядра процессора (самого горячего)
        int fб1_блок_температура_cpu(void)
        {
                // блок работы определения температуры процессора
            double t_now =  sf_температура_cpu(); 
            
            if (глоб_об_нагрузка_оперсист.cpu_t_експотенц_средн >0)
            {
                глоб_об_нагрузка_оперсист.cpu_t_експотенц_средн = глоб_об_нагрузка_оперсист.cpu_t_експотенц_средн *0.80 + 0.20*t_now; 
            }
            else
            {
                глоб_об_нагрузка_оперсист.cpu_t_експотенц_средн = t_now;
            }
            
            глоб_об_нагрузка_оперсист.cpu_t_now = t_now;
            
            return 0;
        }





    
    
// функция по наполнению объекта "нагрузка операционной системы" данными
int fб1_нагрузка_пк(void)
{
    // более универсальный и более быстрый вариант
    int наш_файл;
    char массив_значений_кактекст[15][15];
    int n;
    char buff[100]; // BUFSIZ=16кб       char buff[BUFSIZ];  char buff[100]
    char ch;
    bool новый_блок = false;  

    unsigned long int cpu_тики_реж_пользоват = 0;
    unsigned long int cpu_тики_реж_польз_низк_приорит = 0;
    unsigned long int cpu_тики_режим_системы = 0;
    unsigned long int cpu_тики_режим_простоя = 0;
    
    unsigned long int cpu_тики_нагрузок_новые = 0;
    unsigned long int cpu_тики_всего_новые = 0;
    double cpu_нагрузка_проценты = 0.0; 
    
    unsigned long int cpu_тики_нагрузок_старые;
    unsigned long int cpu_тики_всего_старые;  

    cpu_тики_нагрузок_старые = глоб_об_нагрузка_оперсист.cpu_тики_нагрузок_старые;
    cpu_тики_всего_старые = глоб_об_нагрузка_оперсист.cpu_тики_всего_старые;


    if((наш_файл = open("/proc/stat", O_RDONLY)) == -1) // #include <fcntl.h>
    {
        fprintf(stdout, " Не удаётся открыть файл нагрузки процессора. \n");
        return 1; 
    } 
    
    
    // #include <unistd.h>
    n = read(наш_файл, buff, 100); // BUFSIZ = 16 кб, чуть дольше      read(наш_файл, buff, BUFSIZ)   

    int строка_изфайла = 1;
    int блок_из_строки = 1;
    int позиция_внутри_блока = 0;

    for(int j = 0; j < n; j++) 
    {
        if((ch = buff[j]) == '\n') 
        {
            строка_изфайла++;
            break;
        }
            
        // это общая нагрузка на процессор. записываем данные как текст в текстовой массив (массив указателей)
        if(строка_изфайла == 1) 
        {
            if(ch == ' ' or ch == '\t') 
            {
                новый_блок = true;
                позиция_внутри_блока = 0;
                continue;
            }
            
            // пришлось добавить, т.к два проблема или пробел и табуляция вызывали сбой в работе блок_из_строки
            if(новый_блок == true) 
            {
                блок_из_строки++;
                новый_блок = false;
            }
                
            // первая строка имеет вид cpu  3939633 440808 905738 434303093 450622 0 414898 0 0 0
            // нулевой элемент массива заполняется СЛОВОМ CPU 
            массив_значений_кактекст[блок_из_строки - 1][позиция_внутри_блока] = ch;
            массив_значений_кактекст[блок_из_строки - 1][позиция_внутри_блока + 1] = '\0';
            позиция_внутри_блока++;
        }
    }

    close(наш_файл);
        
    cpu_тики_реж_пользоват= atol(массив_значений_кактекст[1]);
    cpu_тики_реж_польз_низк_приорит =  atol(массив_значений_кактекст[2]);
    cpu_тики_режим_системы =  atol(массив_значений_кактекст[3]);
    cpu_тики_режим_простоя =  atol(массив_значений_кактекст[4]);
    
        // printf("649) %d, %d, %d, %d \n",cpu_тики_реж_пользоват, cpu_тики_реж_польз_низк_приорит, cpu_тики_режим_системы, cpu_тики_режим_простоя);

    cpu_тики_нагрузок_новые =cpu_тики_реж_пользоват + cpu_тики_реж_польз_низк_приорит + cpu_тики_режим_системы;
    cpu_тики_всего_новые = cpu_тики_нагрузок_новые + cpu_тики_режим_простоя;

    cpu_нагрузка_проценты = 100.0 * ((double)(cpu_тики_нагрузок_новые - cpu_тики_нагрузок_старые)) 
             / ((double)(cpu_тики_всего_новые - cpu_тики_всего_старые));
   
    
    if (глоб_об_нагрузка_оперсист.cpu_тики_нагрузок_старые > 0)
    {
        глоб_об_нагрузка_оперсист.cpu_експотенц_средн = глоб_об_нагрузка_оперсист.cpu_експотенц_средн*0.80 + cpu_нагрузка_проценты*0.20; 
    }
    else
    {
        глоб_об_нагрузка_оперсист.cpu_експотенц_средн = cpu_нагрузка_проценты; 
    }
    
    глоб_об_нагрузка_оперсист.cpu_now = cpu_нагрузка_проценты; 
    глоб_об_нагрузка_оперсист.cpu_тики_нагрузок_старые =  cpu_тики_нагрузок_новые;
    глоб_об_нагрузка_оперсист.cpu_тики_всего_старые = cpu_тики_всего_новые;
    
    return 0;
}



